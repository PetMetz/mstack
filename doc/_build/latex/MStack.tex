%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{MStack Documentation}
\date{Apr 03, 2017}
\release{0.1}
\author{Peter C Metz}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\begin{DUlineblock}{0em}
\item[] Peter C. Metz*
\item[] \sphinxstyleemphasis{Inamori School of Engineering, Alfred University, 2 Pine St., Alfred, NY 14802}
\item[] \sphinxstyleemphasis{*Contact: pcm1@alfred.edu \textbar{} (315) 350 1585}
\end{DUlineblock}


\chapter{Abstract:}
\label{\detokenize{index:abstract}}\label{\detokenize{index:mstack-stacking-disorder-tools-for-python}}
In order to refine stacking disorder models in real and reciprocal space, MSTACK has been written to
extend two established profile generators: DIFFaX, a reciprocal space intensity distribution calculator
built on a stochastic stacking disorder model description; and DiffPy-CMI, a suite of tools including pair
distribution function calculators. MSTACK includes tools to expand the stochastic stacking model parameters
typical of DIFFaX into supercell models suitable for calculation of stacking disordered pair distribution function
data, and to drive refinement of layer structure models from real and reciprocal space data.

MSTACK has been designed with advanced refinement tools in mind. MSTACK is built on the code lmfit which
permits the user to include arbitrary constraint equations enabling parametric refinement. Further, MSTACK
is designed to be compatible with any minimizer method in the SciPy package, enabling the application of
global minimization techniques. Currently implemented minimization methods include the L-BFGS-B non-linear
optimization algorithm and the Differential Evolution algorithm. Finally, lmfit and MSTACK enable the user to
apply Markov-Chain Monte Carlo analysis, via the package emcee, to the resulting fit. This Bayesian statistical
analysis tool has been used predominantly in the astronomical community to interpret data with substantial noise
where the error in the data is uncertain. Application of this tool to PDF data suggests many model parameters are
not normally distributed- an insight that is expected to have substantial impact on the future of scattering analysis
of nanostructured material.


\chapter{Contents:}
\label{\detokenize{index:contents}}

\section{background}
\label{\detokenize{rst/background:module-mstack.background}}\label{\detokenize{rst/background::doc}}\label{\detokenize{rst/background:background}}\index{mstack.background (module)}
Created on Thu Mar 30 14:26:43 2017

Background functions for reciprocal-space refinements

@author: Peter C Metz
\index{inv\_x\_plus\_poly3() (in module mstack.background)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/background:mstack.background.inv_x_plus_poly3}}\pysiglinewithargsret{\sphinxcode{mstack.background.}\sphinxbfcode{inv\_x\_plus\_poly3}}{\emph{x}, \emph{a}, \emph{b}, \emph{c}, \emph{d}, \emph{e}}{}
define custom fit function 3rd order polynomial + 1/x term

\end{fulllineitems}



\section{interface}
\label{\detokenize{rst/interface:interface}}\label{\detokenize{rst/interface::doc}}\label{\detokenize{rst/interface:module-mstack.interface}}\index{mstack.interface (module)}
Created on Tue Apr 26 13:54:44 2016

@author: Peter C Metz
\index{Interface (class in mstack.interface)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.interface.}\sphinxbfcode{Interface}}{\emph{phases=None}, \emph{mno=None}, \emph{debug=False}}{}
Bases: \sphinxcode{object}

Interface DIFFaX-Py object with DiffPy Structure/Calculator objects

\_modules return \sphinxstyleemphasis{return self.attribute.update(\{stuff\})} and are accessed
from interface.attribute
\index{\_\_init\_\_() (mstack.interface.Interface method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{phases=None}, \emph{mno=None}, \emph{debug=False}}{}
A collection of tools for retreiving values from Phase object(s) in order
to construct diffpy.Structure objects and PDF calculations therefrom.
\begin{itemize}
\item {} 
Phases: (dict \textbar{} Structure.phase)

\item {} 
mno: (int, int, int): i.e. (1, 2, 3) a sequence of three integers for supercell expansion

\end{itemize}

\end{fulllineitems}

\index{add() (mstack.interface.Interface method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface.add}}\pysiglinewithargsret{\sphinxbfcode{add}}{\emph{attribute}, \emph{value}}{}
generic method

\end{fulllineitems}

\index{expand\_supercell() (mstack.interface.Interface method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface.expand_supercell}}\pysiglinewithargsret{\sphinxbfcode{expand\_supercell}}{\emph{lattice}, \emph{atoms}, \emph{trans}, \emph{dim}, \emph{label}, \emph{debug=False}}{}
Expand first unit cell (\sphinxstyleemphasis{lattice} +  \sphinxstyleemphasis{atoms}) with the transition
vectors in \sphinxstyleemphasis{trans} and the dimension \sphinxstyleemphasis{dim}
\begin{itemize}
\item {} 
lattice: diffpy.Structure.Lattice(a, b, c, alpha, beta, gamma)

\item {} 
atoms: {[}diffpy.Stucture.Atom(1), ..., Atom(N){]}

\item {} 
trans: Transition.transition(alpij, rx, ry, rz, cijk)

\item {} 
dim: intintint (i.e. 123) as dim of supercell

\item {} 
label: label to be applied to supercell

\end{itemize}

\sphinxstylestrong{Returns:} diffpy.Structure instance of supercell

\end{fulllineitems}

\index{is\_Uiso() (mstack.interface.Interface method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface.is_Uiso}}\pysiglinewithargsret{\sphinxbfcode{is\_Uiso}}{\emph{atom}}{}
requires atom as Structure.atom as input
returns boolean discriminating ADP type

\end{fulllineitems}

\index{to\_cif() (mstack.interface.Interface method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface.to_cif}}\pysiglinewithargsret{\sphinxbfcode{to\_cif}}{}{}
write supercells to \sphinxstyleemphasis{supercell.label.cif} in cwd

\end{fulllineitems}

\index{update\_phases() (mstack.interface.Interface method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.Interface.update_phases}}\pysiglinewithargsret{\sphinxbfcode{update\_phases}}{\emph{phases}}{}
phase updater

\end{fulllineitems}


\end{fulllineitems}

\index{is\_dict() (in module mstack.interface)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/interface:mstack.interface.is_dict}}\pysiglinewithargsret{\sphinxcode{mstack.interface.}\sphinxbfcode{is\_dict}}{\emph{d}}{}
returns boolean T\textbar{}F if d passes type check

\end{fulllineitems}



\section{pairdistributionfunction}
\label{\detokenize{rst/pairdistributionfunction:module-mstack.pairdistributionfunction}}\label{\detokenize{rst/pairdistributionfunction::doc}}\label{\detokenize{rst/pairdistributionfunction:pairdistributionfunction}}\index{mstack.pairdistributionfunction (module)}
Created on Tue Apr 19 13:20:59 2016

Designed to integrate lmfit/scipy differential evolution, existing structure
tools, and diffpy PDF generator for global minimization of complex stacking
disorered PDF data.

@author: Peter C Metz
\index{not\_implemented() (in module mstack.pairdistributionfunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.not_implemented}}\pysiglinewithargsret{\sphinxcode{mstack.pairdistributionfunction.}\sphinxbfcode{not\_implemented}}{\emph{parameter}}{}
raise exception if

\end{fulllineitems}

\index{name\_check() (in module mstack.pairdistributionfunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.name_check}}\pysiglinewithargsret{\sphinxcode{mstack.pairdistributionfunction.}\sphinxbfcode{name\_check}}{\emph{iteritem}}{}
check if names in iteritem are unique

\end{fulllineitems}

\index{load() (in module mstack.pairdistributionfunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.load}}\pysiglinewithargsret{\sphinxcode{mstack.pairdistributionfunction.}\sphinxbfcode{load}}{\emph{filename}, \emph{subdir=None}}{}
load a pickled .dat file
Note: if all modules needed by the refinement object are not imported at time of
\begin{quote}

unpickling, there will likely be AttributeErrors thrown.
\end{quote}
\begin{description}
\item[{\textasciitilde{}! actually, this is problematic. cPickle serializes class by reference, nor}] \leavevmode
definition, so changinging the namespace (e.g. adding or removing modules
to this program) will break the pickle.

\end{description}

upgrade to dill which serializes by definition

\end{fulllineitems}



\subsection{pairdistributionfunction.PdfData}
\label{\detokenize{rst/pairdistributionfunction:pairdistributionfunction-pdfdata}}\index{PdfData (class in mstack.pairdistributionfunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfData}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.pairdistributionfunction.}\sphinxbfcode{PdfData}}{\emph{name=None}, \emph{data=None}, \emph{qmax=None}, \emph{qmin=None}, \emph{qbroad=None}, \emph{qdamp=None}, \emph{scale=None}, \emph{rmin=None}, \emph{rmax=None}, \emph{rstep=None}, \emph{use=True}}{}
Bases: {\hyperref[\detokenize{rst/utilities:mstack.utilities.UpdateMethods}]{\sphinxcrossref{\sphinxcode{mstack.utilities.UpdateMethods}}}}, {\hyperref[\detokenize{rst/utilities:mstack.utilities.MergeParams}]{\sphinxcrossref{\sphinxcode{mstack.utilities.MergeParams}}}}

A container for G(r) data which aggregates the miscellaneous necessary values.
\index{\_\_init\_\_() (mstack.pairdistributionfunction.PdfData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfData.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name=None}, \emph{data=None}, \emph{qmax=None}, \emph{qmin=None}, \emph{qbroad=None}, \emph{qdamp=None}, \emph{scale=None}, \emph{rmin=None}, \emph{rmax=None}, \emph{rstep=None}, \emph{use=True}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name} -- as string

\item {} 
\sphinxstyleliteralstrong{data} -- as filepath or (filepath, column) or np.array

\item {} 
\sphinxstyleliteralstrong{qmax} -- as Å ** -1

\item {} 
\sphinxstyleliteralstrong{qmin} -- as Å ** -1

\item {} 
\sphinxstyleliteralstrong{qbroad} -- as Å?? look it up

\item {} 
\sphinxstyleliteralstrong{qdamp} -- as Å?? look it up

\item {} 
\sphinxstyleliteralstrong{scale} -- data scale factor

\item {} 
\sphinxstyleliteralstrong{fit\_min} -- minimum r value for refinement as Å

\item {} 
\sphinxstyleliteralstrong{fit\_max} -- maximum r value for refinement as Å

\item {} 
\sphinxstyleliteralstrong{sampling} -- sampling interval as float or `Nyquist'

\item {} 
\sphinxstyleliteralstrong{use} -- boolean flag for refinment

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_data() (mstack.pairdistributionfunction.PdfData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfData.update_data}}\pysiglinewithargsret{\sphinxbfcode{update\_data}}{\emph{data}, \emph{column=1}}{}
add/upate data  to data object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data} (\sphinxstyleliteralemphasis{str \textbar{} np.array}) -- file path or data array

\item {} 
\sphinxstyleliteralstrong{column} (\sphinxstyleliteralemphasis{int}) -- if read, read from column

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pairdistributionfunction.PdfModel}
\label{\detokenize{rst/pairdistributionfunction:pairdistributionfunction-pdfmodel}}\index{PdfModel (class in mstack.pairdistributionfunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfModel}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.pairdistributionfunction.}\sphinxbfcode{PdfModel}}{\emph{name=None}, \emph{structure=None}, \emph{scale=None}, \emph{delta1=None}, \emph{delta2=None}, \emph{spdiameter=None}, \emph{sthick=None}, \emph{mno=None}, \emph{use=True}, \emph{sratio=None}, \emph{rcut=None}, \emph{stepcut=None}}{}
Bases: {\hyperref[\detokenize{rst/utilities:mstack.utilities.UpdateMethods}]{\sphinxcrossref{\sphinxcode{mstack.utilities.UpdateMethods}}}}, {\hyperref[\detokenize{rst/utilities:mstack.utilities.MergeParams}]{\sphinxcrossref{\sphinxcode{mstack.utilities.MergeParams}}}}

A pdf\_model is a single structure and the associated envelope parameters.
(i.e. scale, Qres, spdiameter, correlated motion delta1\textbar{}delta2).

In the calculation sequence, model+data attributes spawn calculators by passing
config dicts (i.e. PDFcalculator({\color{red}\bfseries{}**}cfg)) which act on the contained diffpy.Structure
to produce a PDF.

pdf\_models are subordinate to pdf\_phases which are the corresponding object to
reciprocal space objects
\index{\_\_init\_\_() (mstack.pairdistributionfunction.PdfModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfModel.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name=None}, \emph{structure=None}, \emph{scale=None}, \emph{delta1=None}, \emph{delta2=None}, \emph{spdiameter=None}, \emph{sthick=None}, \emph{mno=None}, \emph{use=True}, \emph{sratio=None}, \emph{rcut=None}, \emph{stepcut=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name} (\sphinxstyleliteralemphasis{str \textbar{} None}) -- model name

\item {} 
\sphinxstyleliteralstrong{structure} (\sphinxstyleliteralemphasis{diffpy.Structure \textbar{} None}) -- a supercell generated from interface

\item {} 
\sphinxstyleliteralstrong{scale} (\sphinxstyleliteralemphasis{float}) -- scale factor

\item {} 
\sphinxstyleliteralstrong{delta1} (\sphinxstyleliteralemphasis{float}) -- {[}Å{]} component in the broadening equation below

\item {} 
\sphinxstyleliteralstrong{delta2} (\sphinxstyleliteralemphasis{float}) -- {[}Å ** 2{]} component in the broadening equation below

\item {} 
\sphinxstyleliteralstrong{spdiameter} (\sphinxstyleliteralemphasis{float}) -- {[}Å{]} particle diameter in analytic damping function for spherical nanoparticles.

\item {} 
\sphinxstyleliteralstrong{sthick} (\sphinxstyleliteralemphasis{float}) -- {[}Å{]} sheet thickness in analytic damping function (infinite width)

\item {} 
\sphinxstyleliteralstrong{mno} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{list}) -- {[}int{]} (int, int, int) supercell dimensions for expansion of structures

\item {} 
\sphinxstyleliteralstrong{use} (\sphinxstyleliteralemphasis{bool}) -- include in refinement?

\item {} 
\sphinxstyleliteralstrong{sratio} -- {[}-{]} sigma ratio for bonded atoms- peak sharpening due to correlated motion

\item {} 
\sphinxstyleliteralstrong{rcut} -- {[}Å{]} radius cutoff for application of sratio

\item {} 
\sphinxstyleliteralstrong{stepcut} -- {[}Å{]} distance above which G(r) is truncated

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}\begin{description}
\item[{peak width is given by the Jeong peak width model:}] \leavevmode
\(\sigma\)\_ij = \(\sigma\)'\_ij * sqrt(1 - \(\delta\)\_1 / r\_ij - \(\delta\)\_2 / r\textasciicircum{}2\_ij + Q\textasciicircum{}2\_broad * r\textasciicircum{}2\_ij)

\end{description}
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pairdistributionfunction.PdfRefinement}
\label{\detokenize{rst/pairdistributionfunction:pairdistributionfunction-pdfrefinement}}\index{PdfRefinement (class in mstack.pairdistributionfunction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.pairdistributionfunction.}\sphinxbfcode{PdfRefinement}}{\emph{name=None}, \emph{data=None}, \emph{phases=None}}{}
Bases: {\hyperref[\detokenize{rst/utilities:mstack.utilities.UpdateMethods}]{\sphinxcrossref{\sphinxcode{mstack.utilities.UpdateMethods}}}}, {\hyperref[\detokenize{rst/utilities:mstack.utilities.MergeParams}]{\sphinxcrossref{\sphinxcode{mstack.utilities.MergeParams}}}}

A pdf refinement is comprised of a structure model(s) and data to be fit against
\begin{description}
\item[{Contains:}] \leavevmode\begin{itemize}
\item {} 
structure\_exchange- translate Structure object into diffpy.Structure.Structure object

\item {} 
generator- subprocess call to diffpy.srreal.pdfcalculator

\item {} 
residual\_method- ojective function for minimization

\item {} 
callback- tasks to be evaluated at each fit call

\item {} 
lsq\_minimize- least squares minimization wrapper for lmfit

\item {} 
diffev\_minimize- differential evolution minimization wrapper for lmfit

\end{itemize}

\end{description}
\index{\_\_init\_\_() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name=None}, \emph{data=None}, \emph{phases=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name} (\sphinxstyleliteralemphasis{str}) -- PdfRefinement name

\item {} 
\sphinxstyleliteralstrong{data} ({\hyperref[\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfData}]{\sphinxcrossref{\sphinxstyleliteralemphasis{pairdistributionfunction.PdfData}}}}\sphinxstyleliteralemphasis{(}\sphinxstyleliteralemphasis{s}\sphinxstyleliteralemphasis{)}\sphinxstyleliteralemphasis{}) -- list\textbar{}instance of PdfData

\item {} 
\sphinxstyleliteralstrong{phases} (\sphinxstyleliteralemphasis{pairdistributionfunction.PdfPhase}\sphinxstyleliteralemphasis{(}\sphinxstyleliteralemphasis{s}\sphinxstyleliteralemphasis{)}\sphinxstyleliteralemphasis{}) -- list\textbar{}instance of PdfPhase

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{apply\_sheetcf() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.apply_sheetcf}}\pysiglinewithargsret{\sphinxbfcode{apply\_sheetcf}}{\emph{gr}, \emph{sthick}}{}
Apply sheet cf to a 2xN numpy array containing G(r) in angstroms
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{gr} (\sphinxstyleliteralemphasis{np.array}) -- G(r) data array

\item {} 
\sphinxstyleliteralstrong{sthick} (\sphinxstyleliteralemphasis{float}) -- sheet thickness

\end{itemize}

\item[{Returns}] \leavevmode
G(r) data array

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{apply\_sphericalcf() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.apply_sphericalcf}}\pysiglinewithargsret{\sphinxbfcode{apply\_sphericalcf}}{\emph{gr}, \emph{psize}}{}
apply spherical cf to a Nx2 shape numpy array containing G(r)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{gr} (\sphinxstyleliteralemphasis{np.array}) -- G(r) data array

\item {} 
\sphinxstyleliteralstrong{psize} (\sphinxstyleliteralemphasis{float}) -- spherical partical diameter

\end{itemize}

\item[{Returns}] \leavevmode
G(r) data array

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{calculator() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.calculator}}\pysiglinewithargsret{\sphinxbfcode{calculator}}{\emph{model}, \emph{data}}{}
real-space PDF calculation via srreal.pdfcalculator. Calculator built
from attributes of model and data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} ({\hyperref[\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{PdfModel}}}}) -- single instance
(structure, name=None, scale=None, delta1=None, delta2=None,
spdiameter=None, sratio=None, rcut=None, stepcut=None, mno=None)

\item {} 
\sphinxstyleliteralstrong{data} ({\hyperref[\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfData}]{\sphinxcrossref{\sphinxstyleliteralemphasis{PdfData}}}}) -- single instance
(data, name=None, qmax=None, qmin=None, qbroad=None, qdamp=None,
scale=None, rmin=None, rmax=None, rstep=None, use=True)

\end{itemize}

\item[{Returns}] \leavevmode
Calculated (np.array())g(r) scaled by model\_scale only

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Final difference should be calculated from
{\color{red}\bfseries{}**}sum\_i**\{(\sphinxstyleemphasis{data\_scale} * data\_i) - {\color{red}\bfseries{}**}sum\_j**\{\sphinxstyleemphasis{phase\_scale\_j} * {\color{red}\bfseries{}**}sum\_k**\{g(r)\_k\}\}\}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
No shape function applied to calculator result.
\end{sphinxadmonition}

\end{fulllineitems}

\index{callback() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.callback}}\pysiglinewithargsret{\sphinxbfcode{callback}}{\emph{params}, \emph{iter}, \emph{resid}, \emph{*args}, \emph{**kwargs}}{}
Add residual point to dynamic plot, model history
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item {} 
\sphinxstyleliteralstrong{iter} (\sphinxstyleliteralemphasis{int}) -- iteration number

\item {} 
\sphinxstyleliteralstrong{resid} (\sphinxstyleliteralemphasis{array}) -- residual array

\item {} 
\sphinxstyleliteralstrong{kws} (\sphinxstyleliteralemphasis{dict}) -- mostly ignored. use ``plot\_resid''(bool) to initiate
dynamic plot of residual vs. iteration

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Return type is important in this case. I believe a return type of
True causes the minimization to abort.
\end{sphinxadmonition}

\end{fulllineitems}

\index{diffev\_minimize() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.diffev_minimize}}\pysiglinewithargsret{\sphinxbfcode{diffev\_minimize}}{\emph{subdir=None}, \emph{plot\_resid=False}, \emph{sqrt\_filter=False}, \emph{disp=True}, \emph{popsize=5}, \emph{tol=0.1}, \emph{mutation=(0.4}, \emph{0.8)}, \emph{recombination=0.8}, \emph{seed=None}, \emph{polish=False}}{}
Wrapper for lmfit differential\_evolution method (global minimization).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory to stash output files

\item {} 
\sphinxstyleliteralstrong{plot\_resid} (\sphinxstyleliteralemphasis{bool}) -- plot residual vs. iteration

\item {} 
\sphinxstyleliteralstrong{sqrt\_filter} (\sphinxstyleliteralemphasis{bool}) -- plot data scaled by (Yobs) ** 1/2

\item {} 
\sphinxstyleliteralstrong{disp} (\sphinxstyleliteralemphasis{bool}) -- I forget

\item {} 
\sphinxstyleliteralstrong{popsize} (\sphinxstyleliteralemphasis{int}) -- see below

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxstyleliteralemphasis{float}) -- see below

\item {} 
\sphinxstyleliteralstrong{mutation} (\sphinxstyleliteralemphasis{tuple}) -- see below

\item {} 
\sphinxstyleliteralstrong{recombination} (\sphinxstyleliteralemphasis{float}) -- see below

\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{lmfit.Parameter?}) -- see below

\item {} 
\sphinxstyleliteralstrong{polish} (\sphinxstyleliteralemphasis{bool}) -- follow DIFFEV opt by least squares

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
np.array({[}sqrt(yo) - sqrt(yc){]}) if sqrt\_filter is True

\item {} 
np.array({[}yo-yc{]}) if sqrt\_filter is False

\end{itemize}


\end{description}\end{quote}

see scipy.optimize.differential\_evolution for compete list of minimizer keys \& descriptions
\paragraph{Notes}

Differential evolution is a stochastic population based method that is useful for
global optimization problems. At each pass through the population the algorithm
mutates each candidate solution by mixing with other candidate solutions to create
a trial candidate. There are several strategies {[}R141{]} for creating trial candidates,
which suit some problems more than others. The ‘best1bin’ strategy is a good
starting point for many systems. In this strategy two members of the population are
randomly chosen. Their difference is used to mutate the best member
(the best in best1bin), b0, so far:

b’ = b0 + mutation ∗ (population{[}rand0{]} − population{[}rand1{]})

A trial vector is then constructed. Starting with a randomly chosen ‘i’th parameter
the trial is sequentially filled (in modulo) with parameters from b’ or the original
candidate. The choice of whether to use b’ or the original candidate is made
with a binomial distribution  (the ‘bin’ in ‘best1bin’) - a random number in {[}0, 1)
is generated. If this number is less than the recombination constant then the parameter
is loaded from b’, otherwise it is loaded from the original candidate. The final parameter
is always loaded from b’. Once the trial candidate is built its fitness is assessed.
If the trial is better than the original candidate then it takes its place.
If it is also better than the best overall candidate it also replaces that.
To improve your chances of finding a global minimum use higher popsize values,
with higher mutation and (dithering), but lower recombination values.
This has the effect of widening the search radius, but slowing convergence.

{[}R140{]}: Storn, R and Price, K, ``Differential Evolution - a Simple and Efficient Heuristic for Global                     Optimization over Continuous Spaces,'' \sphinxstyleemphasis{Journal of Global Optimization} 11, 341 - 359 (1997).

\end{fulllineitems}

\index{dim\_check() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.dim_check}}\pysiglinewithargsret{\sphinxbfcode{dim\_check}}{\emph{calc\_data}, \emph{exp\_data}}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
len(calc\_data) == len(exp\_data)

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_report() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.filter_report}}\pysiglinewithargsret{\sphinxbfcode{filter\_report}}{\emph{variable=True}, \emph{constrained=False}}{}
print a limited portion of the lmfit minimizer fit report
\textasciitilde{}! moved to utilities

\end{fulllineitems}

\index{generic\_update() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.generic_update}}\pysiglinewithargsret{\sphinxbfcode{generic\_update}}{\emph{params}}{}
generic update method passes parameters to subordinate objects
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item[{Returns}] \leavevmode
True

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{lsq\_minimize() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.lsq_minimize}}\pysiglinewithargsret{\sphinxbfcode{lsq\_minimize}}{\emph{subdir=None}, \emph{plot\_resid=False}, \emph{epsfcn=None}, \emph{xtol=None}, \emph{sqrt\_filter=False}, \emph{method='leastsq'}, \emph{minkws=None}}{}
Wrapper for lmfit least\_squares method (Levenberg-Marquardt)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory to put the DIFFaX input/output into.

\item {} 
\sphinxstyleliteralstrong{plot\_resid} (\sphinxstyleliteralemphasis{bool}) -- toggle dynamic plotting of R vs. iter.

\item {} 
\sphinxstyleliteralstrong{epsfcn} (\sphinxstyleliteralemphasis{float}) -- (default = 1e-02) if step-length is too small the
mininimizer may not progress as no Jacobian is calculated.

\item {} 
\sphinxstyleliteralstrong{xtol} (\sphinxstyleliteralemphasis{float}) -- (default = 1e-04) convergence criterion for the approximate solution.

\item {} 
\sphinxstyleliteralstrong{method} (\sphinxstyleliteralemphasis{str}) -- (default = leastsq) optimizer method (i.e. leastsq, nelder, lbfgsb)

\end{itemize}

\item[{Returns}] \leavevmode
np.array({[}(yo-yc){]})

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
See the SciPy minimizer documentation for full list of minimizer methods.
\end{sphinxadmonition}

\end{fulllineitems}

\index{map\_exp\_calc() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.map_exp_calc}}\pysiglinewithargsret{\sphinxbfcode{map\_exp\_calc}}{\emph{exp\_data}, \emph{calc\_data}, \emph{rmin}, \emph{rmax}}{}
map exp data, calc data onto same array dim and stride
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{exp\_data} (\sphinxstyleliteralemphasis{list array}) -- experimental data

\item {} 
\sphinxstyleliteralstrong{calc\_data} (\sphinxstyleliteralemphasis{list array}) -- calculated data

\item {} 
\sphinxstyleliteralstrong{rmin} (\sphinxstyleliteralemphasis{float}) -- min real space radius

\item {} 
\sphinxstyleliteralstrong{rmax} (\sphinxstyleliteralemphasis{float}) -- max real space radius

\end{itemize}

\item[{Returns}] \leavevmode
exp\_data, (np.array)calc\_data

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{merge\_add() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.merge_add}}\pysiglinewithargsret{\sphinxbfcode{merge\_add}}{\emph{A1}, \emph{A2}}{}
Add A1 and A2, merging length to longest vector if unequal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{A2} (\sphinxstyleliteralemphasis{A1}\sphinxstyleliteralemphasis{,}\sphinxstyleliteralemphasis{}) -- 

\item[{Returns}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{model\_composite() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.model_composite}}\pysiglinewithargsret{\sphinxbfcode{model\_composite}}{\emph{phase}, \emph{data}}{}~\begin{description}
\item[{Populate dict of model components for (PdfPhase)phase and (PdfData)data:}] \leavevmode
Model components: self.gr: \{data\_1: \{phase\_1: \{model\_1: g(r)\_1, ...\}, ...\}, ...\}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phase} (\sphinxstyleliteralemphasis{pairdistributionfunction.PdfPhase}) -- 

\item {} 
\sphinxstyleliteralstrong{data} (\sphinxstyleliteralemphasis{pairdistributionfunction.PdfPhase}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
phase\_scale * sum\_i\{gr\_i\} \textbar{} dtype=float

\end{description}\end{quote}

\end{fulllineitems}

\index{objective\_function() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.objective_function}}\pysiglinewithargsret{\sphinxbfcode{objective\_function}}{\emph{params}, \emph{**kwargs}}{}~
\begin{sphinxadmonition}{note}{Note:}
individual residuals aren't returned for each data set. I'm not
sure how to introduce a weighting scheme yet (all data equally
weighted).
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item {} 
\sphinxstyleliteralstrong{kwargs} -- see below

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{kwargs:}] \leavevmode
-subdir: subdirectory
-plot\_resid: real-time residual plotting (pass thru to callback)

\end{description}

Returns: {\color{red}\bfseries{}**}sum\_i**\{residual\_i\} for i in phases

\end{fulllineitems}

\index{phase\_composite() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.phase_composite}}\pysiglinewithargsret{\sphinxbfcode{phase\_composite}}{\emph{phases}, \emph{data}, \emph{recalc=True}}{}
Get sum of scaled model gr for data. We need to wade through three levels
to get to comprable patterns:
\begin{itemize}
\item {} 
Model components: self.gr: \{data\_1: \{phase\_1: \{model\_1: g(r)\_1, ...\}, ...\}, ...\}

\item {} 
Phase components: self.GR: \{data\_1: \{phase\_1: G(r)\_1, ...\}, ...\}

\item {} 
Phase composite: self.composite: \{data\_1: G(r)\_1, ...\}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phases} (\sphinxstyleliteralemphasis{dict}) -- PdfPhases

\item {} 
\sphinxstyleliteralstrong{data} ({\hyperref[\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfData}]{\sphinxcrossref{\sphinxstyleliteralemphasis{pairdistributionfunction.PdfData}}}}) -- pdf data

\item {} 
\sphinxstyleliteralstrong{recalc} (\sphinxstyleliteralemphasis{bool}) -- not implemented

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
phases --\textgreater{} dict(\{phase.name: phase\}) (plural)

\item {} 
data --\textgreater{} (PdfData) (singular)

\item {} 
shape function applied to each model\_composite G(r)

\item {} 
recalc(default=True) passed in \textbar{} determined at objective function

\end{itemize}
\end{sphinxadmonition}

Returns: None

\end{fulllineitems}

\index{plot\_min\_result() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.plot_min_result}}\pysiglinewithargsret{\sphinxbfcode{plot\_min\_result}}{\emph{data}, \emph{fontsize=12}}{}
Plot the calculated, observed, background and difference curves
of the last computation. Executed at end of every minimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sqrt\_filter} (\sphinxstyleliteralemphasis{bool}) -- plot data scaled by (Yobs) ** 1/2

\item {} 
\sphinxstyleliteralstrong{fontsize} (\sphinxstyleliteralemphasis{float}) -- font size

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib.Figure

\end{description}\end{quote}

\end{fulllineitems}

\index{report\_refined() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.report_refined}}\pysiglinewithargsret{\sphinxbfcode{report\_refined}}{\emph{tabulate=True}}{}
report parameters with attribute vary == True
\textasciitilde{}! moved to utilities

\end{fulllineitems}

\index{reset() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.reset}}\pysiglinewithargsret{\sphinxbfcode{reset}}{}{}
use self.original to reset refined parameters to previous values

\end{fulllineitems}

\index{residual\_method() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.residual_method}}\pysiglinewithargsret{\sphinxbfcode{residual\_method}}{\emph{data}}{}
For each phase in refinement, get DIFFaX pattern and calculate residual
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item {} 
\sphinxstyleliteralstrong{kws} -- see below

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{kws:}] \leavevmode
subdir: subdirectory
plot\_resid: real-time residual plotting (pass thru to callback)
sqrt\_filter: sounds silly, actually just compare sqrt intensities

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
residual with length of data

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{revert() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.revert}}\pysiglinewithargsret{\sphinxbfcode{revert}}{}{}
use self.backup to revert Parameters instance to last minimizer call

\end{fulllineitems}

\index{rwp() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.rwp}}\pysiglinewithargsret{\sphinxbfcode{rwp}}{}{}
calculate rwp for the refinement (utilities method)
.. note:: \textasciitilde{}! not suitable for multiple data

\end{fulllineitems}

\index{save() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.save}}\pysiglinewithargsret{\sphinxbfcode{save}}{\emph{filename=None}, \emph{subdir=None}}{}
Create a pickled save state of the refinement.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- filename.pkl or some such

\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_data() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.update_data}}\pysiglinewithargsret{\sphinxbfcode{update\_data}}{\emph{data}}{}
update data dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{data} (\sphinxstyleliteralemphasis{list?}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_phases() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.update_phases}}\pysiglinewithargsret{\sphinxbfcode{update\_phases}}{\emph{phases}}{}
update structure dict
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phases} (\sphinxstyleliteralemphasis{pairdistributionfunction.PdfPhase}) -- layer phases

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{validate\_diffev() (mstack.pairdistributionfunction.PdfRefinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/pairdistributionfunction:mstack.pairdistributionfunction.PdfRefinement.validate_diffev}}\pysiglinewithargsret{\sphinxbfcode{validate\_diffev}}{}{}
Differential evolution requires min/max values to be supplied for all
variables, not just those that are refined.

This function coerces min/max values from supplied information if none
are given by the user.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{refinement}
\label{\detokenize{rst/refinement:refinement}}\label{\detokenize{rst/refinement:module-mstack.refinement}}\label{\detokenize{rst/refinement::doc}}\index{mstack.refinement (module)}
Created on Thu Dec 03 09:24:07 2015

Designed to integrate lmfit/scipy differential evolution, existing structure
tools, and DIFFaX I(Q) generator for global minimization of complex stacking
disorered powder diffraction data

@author: Peter C Metz
\index{load() (in module mstack.refinement)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.load}}\pysiglinewithargsret{\sphinxcode{mstack.refinement.}\sphinxbfcode{load}}{\emph{filename}, \emph{subdir=None}}{}
load a pickled .dat file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- file to load

\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str \textbar{} None}) -- directory

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
!!!!!!! EXTREMELY IMPORTANT !!!!!!!!!
cPickle saves dependencies by reference. If the source code changes between
execution, save state, and loading, the save state WILL NOT LOAD. THIS WILL
MAKE YOU VERY SAD.

The next step is to switch from pickle to dill, which saves dependencies by
definition. This should make save files compatible across development.

If all modules needed by the refinement object are note imported at time of
unpickling, there will likely be AttributeErrors thrown.
\end{sphinxadmonition}

\end{fulllineitems}



\subsection{refinement.Refinement}
\label{\detokenize{rst/refinement:refinement-refinement}}\index{Refinement (class in mstack.refinement)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.refinement.}\sphinxbfcode{Refinement}}{\emph{wavelength=None}, \emph{exp\_data=None}, \emph{t\_range=None}, \emph{broadening=None}, \emph{background=None}, \emph{phases=None}, \emph{weights=None}, \emph{global\_scale=None}, \emph{lateral\_broadening=None}, \emph{phase\_params=None}, \emph{name=None}}{}
Bases: {\hyperref[\detokenize{rst/utilities:mstack.utilities.MergeParams}]{\sphinxcrossref{\sphinxcode{mstack.utilities.MergeParams}}}}, {\hyperref[\detokenize{rst/utilities:mstack.utilities.UpdateMethods}]{\sphinxcrossref{\sphinxcode{mstack.utilities.UpdateMethods}}}}
\begin{description}
\item[{hierarchy of refinement objects:}] \leavevmode\begin{itemize}
\item {} 
refinement: contains experiment (data, parameters) + phase(s) + weights (normalized to 100\%)

\item {} 
phase: described by a structure + transitions

\item {} 
transitions: holds stacking disorder parameters

\item {} 
structure: holds asymmetric unit and cell parameters

\item {} 
atoms: holds coordinates and isotropic thermal displacement parameters

\end{itemize}

\end{description}

\begin{sphinxadmonition}{note}{Note:}
Specific ref\_to\_phase and phase\_to\_ref methods are depricated by the UpdateMethods
in the utilities module.

I haven't tested the code since replacing the depricated method here.

If this is problematic replace refinement\_to\_phase and phase\_to\_refinement
methods before \_\_init\_\_ and uncomment the appropriate lines (indicated
with in line comments).
\end{sphinxadmonition}
\index{\_\_init\_\_() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{wavelength=None}, \emph{exp\_data=None}, \emph{t\_range=None}, \emph{broadening=None}, \emph{background=None}, \emph{phases=None}, \emph{weights=None}, \emph{global\_scale=None}, \emph{lateral\_broadening=None}, \emph{phase\_params=None}, \emph{name=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{wavelength} (\sphinxstyleliteralemphasis{*}) -- experimental radiation in angstrom

\item {} 
\sphinxstyleliteralstrong{exp\_data} (\sphinxstyleliteralemphasis{*}) -- array like {[}(x1, y1), ..., (xn, yn){]}

\item {} 
\sphinxstyleliteralstrong{t\_range} (\sphinxstyleliteralemphasis{*}) -- 2-theta range like {[}2T\_min, 2T\_max, 2T\_step{]}

\item {} 
\sphinxstyleliteralstrong{broadening} (\sphinxstyleliteralemphasis{*}) -- {[}gau{]} gaussian FWHM or {[}u, v, w, sigma{]} pseudo-voight parameters

\item {} 
\sphinxstyleliteralstrong{background} (\sphinxstyleliteralemphasis{*}) -- list of coefficients to yb = A/x + B + C*x + D*x**2 + E*x**2

\item {} 
\sphinxstyleliteralstrong{phases} (\sphinxstyleliteralemphasis{*}) -- list of phase instance(s) like {[}\textless{}phase\_1\textgreater{}, ... \textless{}phase\_N\textgreater{}{]}

\item {} 
\sphinxstyleliteralstrong{weights} (\sphinxstyleliteralemphasis{*}) -- dictionary of weight percents like \{phase\_1.name: weight\_1, ..., phase\_N.name, weight\_N\}

\item {} 
\sphinxstyleliteralstrong{global\_scale} (\sphinxstyleliteralemphasis{*}) -- global scale factor (float)

\item {} 
\sphinxstyleliteralstrong{lateral\_broadening} (\sphinxstyleliteralemphasis{*}) -- lateral dimension in Angstroms, per DIFFaX Manual (float)

\item {} 
\sphinxstyleliteralstrong{phase\_params} (\sphinxstyleliteralemphasis{*}) -- dict of \{`phase\_name': \textless{}lmfit.Parameters\textgreater{}\}

\item {} 
\sphinxstyleliteralstrong{name} (\sphinxstyleliteralemphasis{*}) -- a string to identify the refinement instance

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{callback() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.callback}}\pysiglinewithargsret{\sphinxbfcode{callback}}{\emph{params}, \emph{iter}, \emph{resid}, \emph{**kws}}{}
Add residual point to dynamic plot, model history
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item {} 
\sphinxstyleliteralstrong{iter} (\sphinxstyleliteralemphasis{int}) -- iteration number

\item {} 
\sphinxstyleliteralstrong{resid} (\sphinxstyleliteralemphasis{array}) -- residual array

\item {} 
\sphinxstyleliteralstrong{kws} (\sphinxstyleliteralemphasis{dict}) -- mostly ignored. use ``plot\_resid''(bool) to initiate
dynamic plot of residual vs. iteration

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Return type is important in this case. I believe a return type of
True causes the minimization to abort.
\end{sphinxadmonition}

\end{fulllineitems}

\index{diffev\_minimize() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.diffev_minimize}}\pysiglinewithargsret{\sphinxbfcode{diffev\_minimize}}{\emph{subdir=None}, \emph{plot\_resid=False}, \emph{sqrt\_filter=False}, \emph{disp=True}, \emph{popsize=5}, \emph{tol=0.1}, \emph{mutation=(0.4}, \emph{0.8)}, \emph{recombination=0.8}, \emph{seed=None}, \emph{polish=False}}{}
Wrapper for lmfit differential\_evolution method (global minimization).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory to stash output files

\item {} 
\sphinxstyleliteralstrong{plot\_resid} (\sphinxstyleliteralemphasis{bool}) -- plot residual vs. iteration

\item {} 
\sphinxstyleliteralstrong{sqrt\_filter} (\sphinxstyleliteralemphasis{bool}) -- plot data scaled by (Yobs) ** 1/2

\item {} 
\sphinxstyleliteralstrong{disp} (\sphinxstyleliteralemphasis{bool}) -- I forget

\item {} 
\sphinxstyleliteralstrong{popsize} (\sphinxstyleliteralemphasis{int}) -- see below

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxstyleliteralemphasis{float}) -- see below

\item {} 
\sphinxstyleliteralstrong{mutation} (\sphinxstyleliteralemphasis{tuple}) -- see below

\item {} 
\sphinxstyleliteralstrong{recombination} (\sphinxstyleliteralemphasis{float}) -- see below

\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{lmfit.Parameter?}) -- see below

\item {} 
\sphinxstyleliteralstrong{polish} (\sphinxstyleliteralemphasis{bool}) -- follow DIFFEV opt by least squares

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
np.array({[}sqrt(yo) - sqrt(yc){]}) if sqrt\_filter is True

\item {} 
np.array({[}yo-yc{]}) if sqrt\_filter is False

\end{itemize}


\end{description}\end{quote}

see scipy.optimize.differential\_evolution for compete list of minimizer keys \& descriptions
\paragraph{Notes}

Differential evolution is a stochastic population based method that is useful for global optimization
problems. At each pass through the population the algorithm mutates each candidate solution by mixing
with other candidate solutions to create a trial candidate. There are several strategies {[}R141{]} for
creating trial candidates, which suit some problems more than others. The ‘best1bin’ strategy is a good
starting point for many systems. In this strategy two members of the population are randomly chosen.
Their difference is used to mutate the best member (the best in best1bin), b0, so far:

b’ = b0 + mutation ∗ (population{[}rand0{]} − population{[}rand1{]})

A trial vector is then constructed. Starting with a randomly chosen ‘i’th parameter the trial is
sequentially filled (in modulo) with parameters from b’ or the original candidate. The choice of
whether to use b’ or the original candidate is made with a binomial distribution
(the ‘bin’ in ‘best1bin’) - a random number in {[}0, 1) is generated. If this number is less than
the recombination constant then the parameter is loaded from b’, otherwise it is loaded from the
original candidate. The final parameter is always loaded from b’. Once the trial candidate is built
its fitness is assessed. If the trial is better than the original candidate then it takes its place.
If it is also better than the best overall candidate it also replaces that. To improve your chances of
finding a global minimum use higher popsize values, with higher mutation and (dithering), but lower
recombination values. This has the effect of widening the search radius, but slowing convergence.

{[}R140{]}: Storn, R and Price, K, ``Differential Evolution - a Simple and Efficient Heuristic for Global                     Optimization over Continuous Spaces,'' \sphinxstyleemphasis{Journal of Global Optimization} 11, 341 - 359 (1997).

\end{fulllineitems}

\index{filter\_report() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.filter_report}}\pysiglinewithargsret{\sphinxbfcode{filter\_report}}{\emph{variable=True}, \emph{constrained=False}}{}
print a limited portion of the lmfit minimizer fit report
\textasciitilde{}! moved to utilities

\end{fulllineitems}

\index{flag() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.flag}}\pysiglinewithargsret{\sphinxbfcode{flag}}{\emph{true=None}, \emph{false=None}}{}
Toggle elements of each list True\textbar{}False respectively
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{true} (\sphinxstyleliteralemphasis{list}) -- parameter name strings

\item {} 
\sphinxstyleliteralstrong{false} (\sphinxstyleliteralemphasis{list}) -- parameter name strings

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{generic\_update() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.generic_update}}\pysiglinewithargsret{\sphinxbfcode{generic\_update}}{\emph{params}}{}
generic update method passes parameters to subordinate objects
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item[{Returns}] \leavevmode
True

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{lsq\_minimize() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.lsq_minimize}}\pysiglinewithargsret{\sphinxbfcode{lsq\_minimize}}{\emph{subdir=None}, \emph{plot\_resid=False}, \emph{epsfcn=None}, \emph{xtol=None}, \emph{sqrt\_filter=False}, \emph{method='leastsq'}, \emph{minkws=None}}{}
Wrapper for lmfit least\_squares method (Levenberg-Marquardt)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory to put the DIFFaX input/output into.

\item {} 
\sphinxstyleliteralstrong{plot\_resid} (\sphinxstyleliteralemphasis{bool}) -- toggle dynamic plotting of R vs. iter.

\item {} 
\sphinxstyleliteralstrong{epsfcn} (\sphinxstyleliteralemphasis{float}) -- (default = 1e-02) if step-length is too small the
mininimizer may not progress as no Jacobian is calculated.

\item {} 
\sphinxstyleliteralstrong{xtol} (\sphinxstyleliteralemphasis{float}) -- (default = 1e-04) convergence criterion for the approximate solution.

\item {} 
\sphinxstyleliteralstrong{method} (\sphinxstyleliteralemphasis{str}) -- (default = leastsq) optimizer method (i.e. leastsq, nelder, lbfgsb)

\end{itemize}

\item[{Returns}] \leavevmode
np.array({[}(yo-yc){]})

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
See the SciPy minimizer documentation for full list of minimizer methods.
\end{sphinxadmonition}

\end{fulllineitems}

\index{map\_calc\_exp\_background() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.map_calc_exp_background}}\pysiglinewithargsret{\sphinxbfcode{map\_calc\_exp\_background}}{\emph{calc\_data}}{}
Map calc, exp, background data onto same array dim and stride
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{calc\_data} (\sphinxstyleliteralemphasis{list}) -- {[}(x1, y1), ..., {]}

\item[{Returns}] \leavevmode
{[}(x1, y1), ...{]}

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_min\_result() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.plot_min_result}}\pysiglinewithargsret{\sphinxbfcode{plot\_min\_result}}{\emph{sqrt\_filter=False}, \emph{fontsize=12}}{}
Plot the calculated, observed, background and difference curves
of the last computation. Executed at end of every minimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sqrt\_filter} (\sphinxstyleliteralemphasis{bool}) -- plot data scaled by (Yobs) ** 1/2

\item {} 
\sphinxstyleliteralstrong{fontsize} (\sphinxstyleliteralemphasis{float}) -- font size

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib.Figure

\end{description}\end{quote}

\end{fulllineitems}

\index{preview() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.preview}}\pysiglinewithargsret{\sphinxbfcode{preview}}{\emph{subdir=None}, \emph{sqrt\_filter=False}}{}
get peak at first calculated state

\end{fulllineitems}

\index{pub\_control() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.pub_control}}\pysiglinewithargsret{\sphinxbfcode{pub\_control}}{\emph{subdir=None}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}}{}
Publish control file for all structures in self.phases
Control.dif written in working directory
Path as os.path.join({\color{red}\bfseries{}*}{[}k for k in {[}subdir, phase{]} if k is not None{]})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory in which to write

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{str}) -- directory in which to write

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{pub\_input() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.pub_input}}\pysiglinewithargsret{\sphinxbfcode{pub\_input}}{\emph{subdir=None}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}}{}
Raises method of phase to refinement level
Passes dictionary of ancillary information (info) to phase.pub\_input to
maintain backwards compatibility with DIFFEV/old input methods
Default behavior is to publish control file for all structures in self.phase
Path as os.path.join({\color{red}\bfseries{}*}{[}k for k in {[}subdir, phase{]} if k is not None{]})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory in which to write

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{str}) -- directory in which to write

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{report\_constrained() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.report_constrained}}\pysiglinewithargsret{\sphinxbfcode{report\_constrained}}{\emph{tabulate=False}}{}
report parameters with attribute expr != None

\end{fulllineitems}

\index{report\_refined() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.report_refined}}\pysiglinewithargsret{\sphinxbfcode{report\_refined}}{\emph{tabulate=False}}{}
report parameters with attribute vary == True
\textasciitilde{}! moved to utilities

\end{fulllineitems}

\index{reset() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.reset}}\pysiglinewithargsret{\sphinxbfcode{reset}}{}{}
use self.original to reset refined parameters to previous values

\end{fulllineitems}

\index{residual\_method() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.residual_method}}\pysiglinewithargsret{\sphinxbfcode{residual\_method}}{\emph{params}, \emph{**kws}}{}
For each phase in refinement, get DIFFaX pattern and calculate residual
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters}) -- 

\item {} 
\sphinxstyleliteralstrong{kws} -- see below

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{kws:}] \leavevmode
subdir: subdirectory
plot\_resid: real-time residual plotting (pass thru to callback)
sqrt\_filter: sounds silly, actually just compare sqrt intensities

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
residual with length of data

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{revert() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.revert}}\pysiglinewithargsret{\sphinxbfcode{revert}}{}{}
use self.backup to revert Parameters instance to last minimizer call

\end{fulllineitems}

\index{rwp() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.rwp}}\pysiglinewithargsret{\sphinxbfcode{rwp}}{\emph{weight=None}}{}~\begin{description}
\item[{calculate rwp for the model:}] \leavevmode
Rwp = \{sum\_m(w\_m * (Yo,m - Yc,m) ** 2) / sum\_m(wm * Yo,m) ** 2\} ** 1/2
wm = 1 / sigma ** 2

\end{description}

weight (length == data)
defalut weight: (Yo,m ** 1/2) ** -2

\end{fulllineitems}

\index{save() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.save}}\pysiglinewithargsret{\sphinxbfcode{save}}{\emph{filename=None}, \emph{subdir=None}}{}
Create a pickled save state of the refinement.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- filename.pkl or some such

\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{str}) -- directory

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_background() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.update_background}}\pysiglinewithargsret{\sphinxbfcode{update\_background}}{\emph{background\_coefficients=None}, \emph{params=None}}{}
update background from list of coefficients or parameters instances
assumes a functional form ybg = A/x + B + C * x + D * x {\color{red}\bfseries{}**}2 + E * x ** 3
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{background\_coefficients} (\sphinxstyleliteralemphasis{list \textbar{} None}) -- 

\item {} 
\sphinxstyleliteralstrong{params} (\sphinxstyleliteralemphasis{lmfit.Parameters \textbar{} None}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_broadening() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.update_broadening}}\pysiglinewithargsret{\sphinxbfcode{update\_broadening}}{\emph{broadening}}{}
update empirical instrumental broadening parameters from list
gaussian broadening: {[}FWHM{]} length 1 argument
pseudo-voight: {[}u, v, w, sigma{]} length 4 argument
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{broadening} (\sphinxstyleliteralemphasis{list}) -- 

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_phase() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.update_phase}}\pysiglinewithargsret{\sphinxbfcode{update\_phase}}{\emph{phases}}{}
add phases to refinement.Phase(s) dict

\end{fulllineitems}

\index{update\_phase\_params() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.update_phase_params}}\pysiglinewithargsret{\sphinxbfcode{update\_phase\_params}}{\emph{phase\_params}}{}
update\textbar{}initialize phase\_params
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phase\_params} (\sphinxstyleliteralemphasis{dict}) -- \{`phase\_name': \textless{}lmfit.Parameters\textgreater{}\}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_theta\_range() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.update_theta_range}}\pysiglinewithargsret{\sphinxbfcode{update\_theta\_range}}{\emph{theta\_range}}{}
Update the refined data range
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{theta\_range} (\sphinxstyleliteralemphasis{list}) -- {[}min, max, stride{]} in units of 2 theta

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_weights() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.update_weights}}\pysiglinewithargsret{\sphinxbfcode{update\_weights}}{\emph{weights}}{}
Update weights.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{weights} (\sphinxstyleliteralemphasis{dict}) -- \{phase name: weight\}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
weights are automatically normalized to 1
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{validate\_diffev() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.validate_diffev}}\pysiglinewithargsret{\sphinxbfcode{validate\_diffev}}{}{}
Differential evolution requires min/max values to be supplied for all
variables, not just those that are refined.

This function coerces min/max values from supplied information if none
are given by the user.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True

\end{description}\end{quote}

\end{fulllineitems}

\index{weighted\_composite() (mstack.refinement.Refinement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/refinement:mstack.refinement.Refinement.weighted_composite}}\pysiglinewithargsret{\sphinxbfcode{weighted\_composite}}{\emph{subdir=None}, \emph{individual=False}, \emph{column=2}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}}{}
Return composite of patterns generated by phases \& associated weighting factors.
looks for phase\_name.spc in pathsubdir

Args:
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
all weighted components
individual is False (list \textbar{} default): {[}(x1, y1), ... {]}

\item[{Return type}] \leavevmode
individual is True (dict)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{structure}
\label{\detokenize{rst/structure::doc}}\label{\detokenize{rst/structure:structure}}
A structure contains atoms (x ,y, z, occ, type, ADP), and
a structure contains a unit cell (a, b, c, \(\alpha\), \(\beta\), \(\gamma\)) and asymmetric
unit (list of atoms).

A phase contains layer structures as well as transitions to
propagate the layer motif in along the perpendicular vector.
The stacking vector is always taken as parallel to \sphinxstylestrong{c}.
\phantomsection\label{\detokenize{rst/structure:module-mstack.structure}}\index{mstack.structure (module)}
Created on Fri Oct 16 16:37:48 2015

A structure is a essentially an enhanced dictionary that contains
lattice parameters and atom instances.

@author: Peter C Metz
\index{build\_cif() (in module mstack.structure)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.build_cif}}\pysiglinewithargsret{\sphinxcode{mstack.structure.}\sphinxbfcode{build\_cif}}{\emph{filename}, \emph{structure\_name=None}, \emph{layer\_number=1}, \emph{path=None}}{}~\begin{quote}

Use PyCifRW to parse a .cif file and output a Structure instance.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
filename (str): pathfilname.extension

\item {} 
structure\_name (str): name for Structure intsance

\item {} 
layer\_number (int): layer number

\item {} 
path (str\textbar{}None): directory

\end{itemize}

\end{description}
\begin{itemize}
\item {} 
currently required site labels as ``TypeNumber''; i.e. Mn1, O5000, Uuo195

\end{itemize}
\begin{description}
\item[{Note:}] \leavevmode
There appears to be an error with parsing a filename containing a complete path.
i.e. C:Path1Path2...

\end{description}
\end{quote}
\begin{description}
\item[{ilename.cif is interpreted as a URL for some dumb reason.}] \leavevmode
The current use of ReadCif simply strips the mount point of your disk drive, which
seems to work so long as the current working directory is on the same disk as your
.cif file.

\end{description}

\end{fulllineitems}



\subsection{structure.Atom}
\label{\detokenize{rst/structure:structure-atom}}\index{Atom (class in mstack.structure)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Atom}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.structure.}\sphinxbfcode{Atom}}{\emph{atom\_name}, \emph{number}, \emph{x}, \emph{y}, \emph{z}, \emph{Uiso\_or\_equiv}, \emph{occ}, \emph{disp\_type='Uiso'}}{}
Bases: \sphinxcode{object}

an atom instance contains its type (name) and number (of its kind) which define
a unique label (i.e. O1, Nb5). x, y, \& z are float fractional coordinates and
Uiso is the thermal displacement parameter (Biso =  8*pi**2*\textless{}u**2\textgreater{} = 8*pi**2*Uiso)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{atom\_name} (\sphinxstyleliteralemphasis{*}) -- atom name

\item {} 
\sphinxstyleliteralstrong{number} (\sphinxstyleliteralemphasis{*}) -- site number

\item {} 
\sphinxstyleliteralstrong{x}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{y}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{*}) -- fractional coordinates

\item {} 
\sphinxstyleliteralstrong{Uiso\_or\_equiv} (\sphinxstyleliteralemphasis{*}) -- isotropic thermal displacement parameter

\item {} 
\sphinxstyleliteralstrong{occ} (\sphinxstyleliteralemphasis{*}) -- occupancy fractional

\item {} 
\sphinxstyleliteralstrong{disp\_type} (\sphinxstyleliteralemphasis{*}) -- `Biso' or `Uiso'

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (mstack.structure.Atom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Atom.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{atom\_name}, \emph{number}, \emph{x}, \emph{y}, \emph{z}, \emph{Uiso\_or\_equiv}, \emph{occ}, \emph{disp\_type='Uiso'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{atom\_name} (\sphinxstyleliteralemphasis{*}) -- atom name

\item {} 
\sphinxstyleliteralstrong{number} (\sphinxstyleliteralemphasis{*}) -- site number

\item {} 
\sphinxstyleliteralstrong{x}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{y}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{*}) -- fractional coordinates

\item {} 
\sphinxstyleliteralstrong{Uiso\_or\_equiv} (\sphinxstyleliteralemphasis{*}) -- isotropic thermal displacement parameter

\item {} 
\sphinxstyleliteralstrong{occ} (\sphinxstyleliteralemphasis{*}) -- occupancy fractional

\item {} 
\sphinxstyleliteralstrong{disp\_type} (\sphinxstyleliteralemphasis{*}) -- `Biso' or `Uiso'

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{structure.Structure}
\label{\detokenize{rst/structure:structure-structure}}\index{Structure (class in mstack.structure)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.structure.}\sphinxbfcode{Structure}}{\emph{name}, \emph{a}, \emph{b}, \emph{c}, \emph{alp=90}, \emph{bet=90}, \emph{gam=90}, \emph{atoms=None}, \emph{number=1}}{}
Bases: {\hyperref[\detokenize{rst/utilities:mstack.utilities.UpdateMethods}]{\sphinxcrossref{\sphinxcode{mstack.utilities.UpdateMethods}}}}, {\hyperref[\detokenize{rst/utilities:mstack.utilities.MergeParams}]{\sphinxcrossref{\sphinxcode{mstack.utilities.MergeParams}}}}

A structure instance contains the lattice and asymmetric unit,
presently limited only to P1 symmetry, of a layer structure.
\index{\_\_init\_\_() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name}, \emph{a}, \emph{b}, \emph{c}, \emph{alp=90}, \emph{bet=90}, \emph{gam=90}, \emph{atoms=None}, \emph{number=1}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} (\sphinxstyleliteralemphasis{*}) -- lattice parameter a {[}Å{]}

\item {} 
\sphinxstyleliteralstrong{b} (\sphinxstyleliteralemphasis{*}) -- lattice parameter b {[}Å{]}

\item {} 
\sphinxstyleliteralstrong{c} (\sphinxstyleliteralemphasis{*}) -- lattice parameter c {[}Å{]}

\item {} 
\sphinxstyleliteralstrong{alp} (\sphinxstyleliteralemphasis{*}) -- lattice parameter alpha {[}°{]}   \sphinxstyleemphasis{default = 90}

\item {} 
\sphinxstyleliteralstrong{bet} (\sphinxstyleliteralemphasis{*}) -- lattice parameter beta {[}°{]}   \sphinxstyleemphasis{default = 90}

\item {} 
\sphinxstyleliteralstrong{gam} (\sphinxstyleliteralemphasis{*}) -- lattice parameter gamma {[}°{]}   \sphinxstyleemphasis{default  = 90}

\item {} 
\sphinxstyleliteralstrong{atoms} (\sphinxstyleliteralemphasis{*}) -- list of atom instances   \sphinxstyleemphasis{default = None}

\item {} 
\sphinxstyleliteralstrong{number} (\sphinxstyleliteralemphasis{*}) -- layer number {[}integer{]} used to index layer when building transition matrix

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
In DIFFaX alpha and beta are constrained to 90°- only gamma may vary. These are presently
included as a formality.
\end{sphinxadmonition}

\end{fulllineitems}

\index{get\_all\_par() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.get_all_par}}\pysiglinewithargsret{\sphinxbfcode{get\_all\_par}}{}{}~\begin{description}
\item[{returns dictionary of all paramters stored in structure, e.g.:}] \leavevmode\begin{itemize}
\item {} 
lattice parameters (vector magnitudes and angles)

\item {} 
atom parameters (x, y, z, occ, Uiso)

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\{{[}atom.label{]}\_{[}par{]}: value, ...\}

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_atom\_par() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.get_atom_par}}\pysiglinewithargsret{\sphinxbfcode{get\_atom\_par}}{\emph{par}}{}
return atom par(str) with keys label\_par (dict)

\end{fulllineitems}

\index{lattice\_angles() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.lattice_angles}}\pysiglinewithargsret{\sphinxbfcode{lattice\_angles}}{}{}
return lattice angles as variables (dict)

\end{fulllineitems}

\index{lattice\_params() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.lattice_params}}\pysiglinewithargsret{\sphinxbfcode{lattice\_params}}{}{}
return lattice parameters as variables (dict)

\end{fulllineitems}

\index{merge\_adp() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.merge_adp}}\pysiglinewithargsret{\sphinxbfcode{merge\_adp}}{\emph{atoms}}{}
get list of atom ADPS in common ADP type (Biso)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{atoms} (\sphinxstyleliteralemphasis{*}) -- list of atom instances

\end{description}\end{quote}

\end{fulllineitems}

\index{parameters() (mstack.structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Structure.parameters}}\pysiglinewithargsret{\sphinxbfcode{parameters}}{\emph{*valid\_keys}}{}
Creates a lmfit Parameters instance from the contents of structure.

All pars come fixed by default- user will flag enteries for
refinment using the Parameters method instance{[}'parname'{]}.vary=Boolean.

If a list of keywords is passed, parameters() will attempt to assemble a
Parameters instance using the valid keys and reporting the invalid keys
(i.e. {[}'a', `b', `c', `Ox'{]}... returned params.keys()= `a', `b', `c'): invalid
key `ox'.)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{valid\_keys} (\sphinxstyleliteralemphasis{str}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{list}) -- parameter keys

\item[{Returns}] \leavevmode
instance containing {\color{red}\bfseries{}*}valid\_keys

\item[{Return type}] \leavevmode
lmfit.Parameters

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{structure.Phase}
\label{\detokenize{rst/structure:structure-phase}}\index{Phase (class in mstack.structure)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.structure.}\sphinxbfcode{Phase}}{\emph{name}, \emph{transitions=None}, \emph{structures=None}, \emph{parameters=None}, \emph{redchi=None}, \emph{broadening=None}, \emph{mcl=None}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}}{}
Bases: {\hyperref[\detokenize{rst/utilities:mstack.utilities.MergeParams}]{\sphinxcrossref{\sphinxcode{mstack.utilities.MergeParams}}}}, {\hyperref[\detokenize{rst/utilities:mstack.utilities.UpdateMethods}]{\sphinxcrossref{\sphinxcode{mstack.utilities.UpdateMethods}}}}

A Phase contains the layer structure and transition(s) to be expanded into
a refinable supercell model.

Multiple Phase objects can be fed to the Refinement object to accout for
polytypism or multiphase data, etc.
\index{\_\_init\_\_() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name}, \emph{transitions=None}, \emph{structures=None}, \emph{parameters=None}, \emph{redchi=None}, \emph{broadening=None}, \emph{mcl=None}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{transitions- transitions instance} (\sphinxstyleliteralemphasis{*}) -- 

\item {} 
\sphinxstyleliteralstrong{structures- list of structure instances} (\sphinxstyleliteralemphasis{*}) -- 

\item {} 
\sphinxstyleliteralstrong{parameters- lmfit parameters instance} (\sphinxstyleliteralemphasis{*}) -- 

\item {} 
\sphinxstyleliteralstrong{redchi - reduced chi value of last iteration} (\sphinxstyleliteralemphasis{*}) -- 

\item {} 
\sphinxstyleliteralstrong{broadening -}\sphinxstyleliteralstrong{ {[}}\sphinxstyleliteralstrong{FWHM}\sphinxstyleliteralstrong{{]} }\sphinxstyleliteralstrong{\textbar{}}\sphinxstyleliteralstrong{ {[}}\sphinxstyleliteralstrong{u}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{v}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{w}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{sigma}\sphinxstyleliteralstrong{{]}}\sphinxstyleliteralstrong{} (\sphinxstyleliteralemphasis{*}) -- 

\item {} 
\sphinxstyleliteralstrong{mcl - mean column length} (\sphinxstyleliteralemphasis{*}) -- 

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{*}) -- directory path

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{initialize\_structure\_params() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.initialize_structure_params}}\pysiglinewithargsret{\sphinxbfcode{initialize\_structure\_params}}{\emph{stru}}{}
initialize structure parameters as lmfit parameters for stru(s)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{stru} (\sphinxstyleliteralemphasis{*}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{pub\_control() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.pub_control}}\pysiglinewithargsret{\sphinxbfcode{pub\_control}}{\emph{info}, \emph{inputname='diffax\_in.dat'}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}, \emph{subdir=None}}{}
write control file for single file inputname.dat
supply T\_min, {\color{red}\bfseries{}T\_max\_} T\_step as info \textasciitilde{}! this will change at some point
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{info} (\sphinxstyleliteralemphasis{*}) -- theta information (min, max, step)

\item {} 
\sphinxstyleliteralstrong{inputname} (\sphinxstyleliteralemphasis{*}) -- .dat file for DIFFaX to munch crunch upon

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{*}) -- directory

\item {} 
\sphinxstyleliteralstrong{subdir} (\sphinxstyleliteralemphasis{*}) -- more directory info... probably scrap this

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
None

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{pub\_input() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.pub_input}}\pysiglinewithargsret{\sphinxbfcode{pub\_input}}{\emph{info}, \emph{inputname='diffax\_in'}, \emph{path='/media/sf\_Dropbox/Thesis/MStack/mstack\_0.1/doc'}, \emph{subdir=None}}{}
Distill phase into diffax input file inputname.dat.

At the moment, ancillary information is not stored in model- i.e. radiation type,
2-theta limits, etc... needs to be passed in
needed (key):
\begin{itemize}
\item {} 
wavelength (wvl)

\item {} 
broadening parameters (gau) \textasciitilde{}! only gaussian implimented right now!

\item {} 
lateral braodening (lat) -- this is optional

\item {} 
Mean Column Length (MCL)

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{info} (\sphinxstyleliteralemphasis{*}) -- indicated above

\item {} 
\sphinxstyleliteralstrong{inputname} (\sphinxstyleliteralemphasis{*}) -- fname

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
None

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{report\_refined() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.report_refined}}\pysiglinewithargsret{\sphinxbfcode{report\_refined}}{}{}
returns dict of items with self.params{[}item{]}.vary == True

\end{fulllineitems}

\index{toggle() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.toggle}}\pysiglinewithargsret{\sphinxbfcode{toggle}}{\emph{flags=None}}{}
set refinement\_flags to refine

flags (str): parameter names to togggle vary - True

\end{fulllineitems}

\index{update\_mcl() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.update_mcl}}\pysiglinewithargsret{\sphinxbfcode{update\_mcl}}{\emph{mcl}}{}
Create mean column length and MCL/1022 variabels. DIFFaX interprets
mcl \textgreater{}= 1022 as infinite crystallites, hence the normalization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{mcl} (\sphinxstyleliteralemphasis{*}) -- 1 \textless{}= mean column length \textless{}= 1022

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_structures() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.update_structures}}\pysiglinewithargsret{\sphinxbfcode{update\_structures}}{\emph{stru}}{}
add/update structure to/in model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{stru} (\sphinxstyleliteralemphasis{*}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_transitions() (mstack.structure.Phase method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/structure:mstack.structure.Phase.update_transitions}}\pysiglinewithargsret{\sphinxbfcode{update\_transitions}}{\emph{T}}{}
add/update transition to/in model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{T} ({\hyperref[\detokenize{rst/transition:mstack.transition.Transitions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{transition.Transitions}}}}) -- 

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{supercell}
\label{\detokenize{rst/supercell:supercell}}\label{\detokenize{rst/supercell:module-mstack.supercell}}\label{\detokenize{rst/supercell::doc}}\index{mstack.supercell (module)}
Created on Wed Mar 02 11:34:35 2016

quick script to translate Structure instances into supercells
-copy/shift asymmetric unit according to single vector
-accept user dimension (N-units along c-vector) or default to MCL
-dump .xyz file and/or .cif (P1) file for visualization and supercell PDF


\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~pub\_cif}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~pub\_xyz}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~supercell}}
\end{fulllineitems}


@author: Peter C. Metz
\index{pub\_cif() (in module mstack.supercell)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/supercell:mstack.supercell.pub_cif}}\pysiglinewithargsret{\sphinxcode{mstack.supercell.}\sphinxbfcode{pub\_cif}}{\emph{a}, \emph{b}, \emph{c}, \emph{gam}, \emph{asym}, \emph{path}, \emph{filename}}{}
publish a structure in .cif format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{b}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{c}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{gam} (\sphinxstyleliteralemphasis{a}\sphinxstyleliteralemphasis{,}\sphinxstyleliteralemphasis{}) -- lattice parameters

\item {} 
\sphinxstyleliteralstrong{asym} (\sphinxstyleliteralemphasis{list}) -- list of structure.Atoms

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{str}) -- directory of file.cif

\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- filname for dump (omit .cif)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pub\_xyz() (in module mstack.supercell)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/supercell:mstack.supercell.pub_xyz}}\pysiglinewithargsret{\sphinxcode{mstack.supercell.}\sphinxbfcode{pub\_xyz}}{\emph{a}, \emph{b}, \emph{c}, \emph{gam}, \emph{asym}, \emph{path}, \emph{filename}}{}
write .xyz as
\textless{}N atoms\textgreater{}
\textless{}comment line\textgreater{}
\textless{} atom\textgreater{} \textless{}x\textgreater{} \textless{}y\textgreater{} \textless{}z\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{b}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{c}\sphinxstyleliteralstrong{, }\sphinxstyleliteralstrong{gam} (\sphinxstyleliteralemphasis{a}\sphinxstyleliteralemphasis{,}\sphinxstyleliteralemphasis{}) -- lattice parameters

\item {} 
\sphinxstyleliteralstrong{asym} (\sphinxstyleliteralemphasis{list}) -- list of structure.Atoms

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{str}) -- directory of file.xyz

\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- filname for dump (omit .xyz)

\end{itemize}

\end{description}\end{quote}

@!!!!!! Orthogonal vector space conversion is broken

\end{fulllineitems}

\index{supercell() (in module mstack.supercell)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/supercell:mstack.supercell.supercell}}\pysiglinewithargsret{\sphinxcode{mstack.supercell.}\sphinxbfcode{supercell}}{\emph{struct}, \emph{vector}, \emph{N=None}, \emph{cif=True}, \emph{xyz=False}, \emph{path=None}, \emph{filename=None}, \emph{debug=False}}{}
Dump a supercell model for input structure and vector with dim 1x1xN.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{struct} ({\hyperref[\detokenize{rst/structure:mstack.structure.Structure}]{\sphinxcrossref{\sphinxstyleliteralemphasis{structure.Structure}}}}) -- layer structure

\item {} 
\sphinxstyleliteralstrong{vector} (\sphinxstyleliteralemphasis{list}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{dict}) -- layer vector in fractional values

\item {} 
\sphinxstyleliteralstrong{N} (\sphinxstyleliteralemphasis{bool \textbar{} None}) -- supercell dimension

\item {} 
\sphinxstyleliteralstrong{cif} (\sphinxstyleliteralemphasis{bool\textbar{} True}) -- output cif?

\item {} 
\sphinxstyleliteralstrong{xyz} (\sphinxstyleliteralemphasis{bool \textbar{} False}) -- output xyz?

\item {} 
\sphinxstyleliteralstrong{path} (\sphinxstyleliteralemphasis{str\textbar{}None}) -- directory

\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str\textbar{}None}) -- filename

\item {} 
\sphinxstyleliteralstrong{debug} (\sphinxstyleliteralemphasis{bool\textbar{}False}) -- return expanded asymmetric unit

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\begin{quote}
\end{quote}


\section{transition}
\label{\detokenize{rst/transition:transition}}\label{\detokenize{rst/transition::doc}}

\subsection{transition.Transition}
\label{\detokenize{rst/transition:transition-transition}}\index{Transition (class in mstack.transition)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.transition.}\sphinxbfcode{Transition}}{\emph{i}, \emph{j}, \emph{alpij=None}, \emph{vector=None}, \emph{cij=None}}{}
Bases: \sphinxcode{object}

instantiate a transition to create empty variables that satisfy the
program requirements of DIFFaX. Parameters include transition index n,
transition probability alphaij, vector R, and uncertainty cij


\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~generic}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~scale\_cij}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~update\_cij}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~update\_alpij}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~update\_vector}}
\end{fulllineitems}

\index{\_\_init\_\_() (mstack.transition.Transition method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{i}, \emph{j}, \emph{alpij=None}, \emph{vector=None}, \emph{cij=None}}{}
Announce components of the nth transition. Defaults = 0.0.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{alpij} (\sphinxstyleliteralemphasis{dict}) -- \{`alpn1': float, ..., `alpnN': float\} dim(n\_layers)

\item {} 
\sphinxstyleliteralstrong{vector} (\sphinxstyleliteralemphasis{dict}) -- \{`rx': float, `ry': float `rz': float\}

\item {} 
\sphinxstyleliteralstrong{cij} (\sphinxstyleliteralemphasis{dict}) -- \{`c11': float, `c22': float, `c33': float, `c12': float, `c13': float, `c23': float\}

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Pass additional information  as tuple, e.g.
(value {[}, True\textbar{}False {[}, min, max{]}{]})
\end{sphinxadmonition}

\end{fulllineitems}

\index{generic() (mstack.transition.Transition method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition.generic}}\pysiglinewithargsret{\sphinxbfcode{generic}}{\emph{generic}, \emph{name}, \emph{min0=0.0}, \emph{max0=1.0}}{}
Method for updating params.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{generic} (\sphinxstyleliteralemphasis{dict}) -- \{key: (value {[}, True\textbar{}False {[}, min, max{]}{]}), ...\}
optional vary boolean, min, max as positional args

\item {} 
\sphinxstyleliteralstrong{name} (\sphinxstyleliteralemphasis{str}) -- alpij\textbar{}cij\textbar{}vector

\end{itemize}

\item[{Returns}] \leavevmode
sets parameter and updates appropriate attribute

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_cij() (mstack.transition.Transition method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition.scale_cij}}\pysiglinewithargsret{\sphinxbfcode{scale\_cij}}{\emph{force=False}}{}
scale cij by smaller corresponding cii to satisfy requirement that
cij \textless{}= cii
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{force} (\sphinxstyleliteralemphasis{bool}) -- executes scaling whether or not self.scaled is True

\item[{Returns}] \leavevmode
True

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_alpij() (mstack.transition.Transition method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition.update_alpij}}\pysiglinewithargsret{\sphinxbfcode{update\_alpij}}{\emph{alpij}}{}
initialize/update transition probabilities (dim(n))

\end{fulllineitems}

\index{update\_cij() (mstack.transition.Transition method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition.update_cij}}\pysiglinewithargsret{\sphinxbfcode{update\_cij}}{\emph{cij}}{}
initialize/update cij (fractions) and scaled\_cij (appropriately scaled copy)

\end{fulllineitems}

\index{update\_vector() (mstack.transition.Transition method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transition.update_vector}}\pysiglinewithargsret{\sphinxbfcode{update\_vector}}{\emph{vector}}{}
initialize/update vector

\end{fulllineitems}


\end{fulllineitems}



\subsection{transition.Transitions}
\label{\detokenize{rst/transition:transition-transitions}}\index{Transitions (class in mstack.transition)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.transition.}\sphinxbfcode{Transitions}}{\emph{nlayers=None}, \emph{transitions=None}}{}
Bases: \sphinxcode{object}

Container for all the transitions specifying a stacking disorder problem.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~pub\_trans}}
method to publish transitions block in DIFFaX format. I.e.:
\{alpij     Rxj     Ryj     Rzj     (clm)\}
1.0000000000 0.3550 0.3550 1.0000 (10.0000 10.0000 2.0000 0.0000 0.0000 0.0000) \{1-1\}
...
\begin{quote}

\{N-N\}
\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~row\_normal}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~todict}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~update\_transitions}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{*~validate\_transitions}}
\end{fulllineitems}

\index{\_\_init\_\_() (mstack.transition.Transitions method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{nlayers=None}, \emph{transitions=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{transitions} (\sphinxstyleliteralemphasis{list}) -- list containing transition instances

\item {} 
\sphinxstyleliteralstrong{nlayers} (\sphinxstyleliteralemphasis{int}) -- number of layer types (N)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pub\_trans() (mstack.transition.Transitions method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions.pub_trans}}\pysiglinewithargsret{\sphinxbfcode{pub\_trans}}{}{}
publish the transition information in DIFFaX suitable format, e.g.
alpij Rx Ry Rz (Cijk) \{i-j\}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of transitions in DIFFaX format (string lists) (0th element always empty)

\end{description}\end{quote}

\end{fulllineitems}

\index{row\_normal() (mstack.transition.Transitions method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions.row_normal}}\pysiglinewithargsret{\sphinxbfcode{row\_normal}}{\emph{row=0}}{}
row normalize entries in alpij

\end{fulllineitems}

\index{todict() (mstack.transition.Transitions method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions.todict}}\pysiglinewithargsret{\sphinxbfcode{todict}}{}{}
map numpy array as dict

\end{fulllineitems}

\index{update\_transitions() (mstack.transition.Transitions method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions.update_transitions}}\pysiglinewithargsret{\sphinxbfcode{update\_transitions}}{\emph{transitions}}{}
initialize/update dictionary of transitions

\end{fulllineitems}

\index{validate\_transitions() (mstack.transition.Transitions method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/transition:mstack.transition.Transitions.validate_transitions}}\pysiglinewithargsret{\sphinxbfcode{validate\_transitions}}{\emph{force=False}}{}~
\begin{sphinxadmonition}{note}{Note:}
Because empty fields are initialized with appropriate values except for probabilities,
we really just need to confirm the user supplied probabilities and that they:
\begin{enumerate}
\item {} 
are row normalized.

\item {} 
of uniform dimension (N x N)

\end{enumerate}

These conditions are enforced (transitions are operated on) if not correct
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{force} (\sphinxstyleliteralemphasis{bool \textbar{} False}) -- recompute scaled cij whether or not trans.scaled is True

\item[{Returns}] \leavevmode
True\textbar{}False

\item[{Return type}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{utilities}
\label{\detokenize{rst/utilities:module-mstack.utilities}}\label{\detokenize{rst/utilities::doc}}\label{\detokenize{rst/utilities:utilities}}\index{mstack.utilities (module)}
Created on Thu Dec 03 13:28:46 2015

Common utility classes and functions for MStack.

@author: Peter C Metz
\index{DynamicPlot (class in mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.DynamicPlot}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.utilities.}\sphinxbfcode{DynamicPlot}}{\emph{fontsize=14}}{}
Bases: \sphinxcode{object}

Plotting utility used to create output for itterative function.
Called in minimizer callback function to create Rwp  vs.  iter
Reserves plot number 100 for this purpose.

call signiture: DynamicPlot(xdata, ydata) --\textgreater{} appended point to plot
\index{\_\_init\_\_() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.DynamicPlot.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{fontsize=14}}{}
\end{fulllineitems}

\index{on\_launch() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.DynamicPlot.on_launch}}\pysiglinewithargsret{\sphinxbfcode{on\_launch}}{}{}
set up plot

\end{fulllineitems}

\index{on\_running() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.DynamicPlot.on_running}}\pysiglinewithargsret{\sphinxbfcode{on\_running}}{\emph{new\_x}, \emph{new\_y}}{}
update plot

\end{fulllineitems}


\end{fulllineitems}

\index{MergeParams (class in mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.MergeParams}}\pysigline{\sphinxstrong{class }\sphinxcode{mstack.utilities.}\sphinxbfcode{MergeParams}}
Bases: \sphinxcode{object}

Tools to merge Parmeters instances between objects containing them while
maintaining unique parameter names.

The result is an lmfit.Parameters object on the top class with the name `params'
(so call your lmfit.Parameters instance params if you want this to work smoothly)
Although the specification of lmfit.Parameters attributes as other names works
with specifier
\index{add\_set\_params() (mstack.utilities.MergeParams method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.MergeParams.add_set_params}}\pysiglinewithargsret{\sphinxbfcode{add\_set\_params}}{\emph{name=None}, \emph{value=None}, \emph{vary=None}, \emph{min=None}, \emph{max=None}, \emph{expr=None}}{}
add/set parameter in refinement parameters

for list of supported mathematics, see:
\url{http://lmfit.github.io/lmfit-py/constraints.html\#supported-operators-functions-and-constants}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name} (\sphinxstyleliteralemphasis{str}) -- parameter name

\item {} 
\sphinxstyleliteralstrong{value} (\sphinxstyleliteralemphasis{float}) -- parameter value

\item {} 
\sphinxstyleliteralstrong{vary} (\sphinxstyleliteralemphasis{bool}) -- vary in refinement?

\item {} 
\sphinxstyleliteralstrong{min} (\sphinxstyleliteralemphasis{float}) -- minimum bound

\item {} 
\sphinxstyleliteralstrong{max} (\sphinxstyleliteralemphasis{float}) -- maximum bound

\item {} 
\sphinxstyleliteralstrong{expr} (\sphinxstyleliteralemphasis{str}) -- constrain expression.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{exists() (mstack.utilities.MergeParams method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.MergeParams.exists}}\pysiglinewithargsret{\sphinxbfcode{exists}}{\emph{attribute}, \emph{value=None}}{}
check if attribute exists in object \textbar{} create with value(None) else

\end{fulllineitems}

\index{lower\_to\_upper() (mstack.utilities.MergeParams method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.MergeParams.lower_to_upper}}\pysiglinewithargsret{\sphinxbfcode{lower\_to\_upper}}{\emph{top\_attribute}, \emph{specifier=None}}{}
When merging lmfit.Parameters instances belonging to different constituent refinement
objects, we run into an issue of unique variable naming (x occurs for each atom coodinate,
i.e.)

The transmogrifier appends the top\_attribute.name to the bottom\_attribute.Parameter.name attribute
to construct a unique variable label. This change is propagated to variables in the instance's
constraint expression to maintain validity.
\begin{description}
\item[{i.e top\_attribute = (attribute as str) indicating dictionary of subordinate objects}] \leavevmode
bottom\_attribute = params instance subordinate object

\end{description}

\end{fulllineitems}

\index{param\_finder() (mstack.utilities.MergeParams method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.MergeParams.param_finder}}\pysiglinewithargsret{\sphinxbfcode{param\_finder}}{\emph{bottom\_attribute}, \emph{specifier}}{}
get parameter instance from subordinate object

\end{fulllineitems}

\index{upper\_to\_lower() (mstack.utilities.MergeParams method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.MergeParams.upper_to_lower}}\pysiglinewithargsret{\sphinxbfcode{upper\_to\_lower}}{\emph{top\_attribute}, \emph{specifier=None}, \emph{debug=False}}{}~\begin{itemize}
\item {} \begin{description}
\item[{top\_attribute: attribute name for dict of subordinate objects}] \leavevmode
i.e. `phases' --\textgreater{} refinement.phases = \{`phase\_1': \textless{}PairDistributionFunction.PdfPhase\textgreater{}\}

\end{description}

\item {} 
specifier: name of parameters instance in subordinate object

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{UpdateMethods (class in mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.UpdateMethods}}\pysigline{\sphinxstrong{class }\sphinxcode{mstack.utilities.}\sphinxbfcode{UpdateMethods}}
Bases: \sphinxcode{object}

Generic update methods for the data types dealt with in pdf refinement objects
\begin{itemize}
\item {} 
initialize: set attribute for class if it doesn't exist, add Parameter instance

\item {} 
update: update an initialized parameter with appropriate method

\item {} 
update\_with\_limits: update when value received as (value, min, max)

\item {} 
update\_with\_lmfit: update when value received as lmfit.Parameter instance

\end{itemize}
\index{initialize() (mstack.utilities.UpdateMethods method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.UpdateMethods.initialize}}\pysiglinewithargsret{\sphinxbfcode{initialize}}{\emph{attribute}, \emph{value=None}}{}
default variable initialization

\end{fulllineitems}

\index{update() (mstack.utilities.UpdateMethods method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.UpdateMethods.update}}\pysiglinewithargsret{\sphinxbfcode{update}}{\emph{attribute}, \emph{value=None}}{}
default update mode

\end{fulllineitems}

\index{update\_with\_limits() (mstack.utilities.UpdateMethods method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.UpdateMethods.update_with_limits}}\pysiglinewithargsret{\sphinxbfcode{update\_with\_limits}}{\emph{attribute}, \emph{tup}}{}
allow args passed as (value, min, max)

\end{fulllineitems}

\index{update\_with\_lmfit() (mstack.utilities.UpdateMethods method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.UpdateMethods.update_with_lmfit}}\pysiglinewithargsret{\sphinxbfcode{update\_with\_lmfit}}{\emph{attribute}, \emph{parameter}}{}
update self.params with Parameter instance

\end{fulllineitems}


\end{fulllineitems}

\index{attributegetter() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.attributegetter}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{attributegetter}}{\emph{items}}{}
Return a callable object that retrieves named \sphinxstyleemphasis{attributes} from its operand
using the objects \_\_getattribute\_\_() method. This is analagous to the built-in
operator \sphinxstyleemphasis{operator.itemgetter}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{items} (\sphinxstyleliteralemphasis{str}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{list}) -- attribute names

\item[{Returns}] \leavevmode
callable object that retreives attribute values from the operand

\end{description}\end{quote}

\end{fulllineitems}

\index{checkequal() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.checkequal}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{checkequal}}{\emph{iterator}}{}
Check if subsequent iterables are equivilant
used only in Structure.pub\_input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{iterator} (\sphinxstyleliteralemphasis{iterable}) -- 

\item[{Returns}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_report() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.filter_report}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{filter\_report}}{\emph{refinement}, \emph{variable=True}, \emph{constrained=False}, \emph{\_print=True}, \emph{\_text=False}}{}
print a limited portion of the lmfit minimizer fit report.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{refinement} (\sphinxstyleliteralemphasis{Refinement instance}) -- Pdf or I(Q) Refinement instance

\item {} 
\sphinxstyleliteralstrong{variable} (\sphinxstyleliteralemphasis{bool\textbar{}True}) -- report refined variables

\item {} 
\sphinxstyleliteralstrong{constrained} (\sphinxstyleliteralemphasis{bool\textbar{}False}) -- report constrained variables

\item {} 
\sphinxstyleliteralstrong{\_print} (\sphinxstyleliteralemphasis{bool\textbar{}True}) -- print output

\item {} 
\sphinxstyleliteralstrong{\_text} (\sphinxstyleliteralemphasis{bool\textbar{}False}) -- list output

\end{itemize}

\item[{Returns}] \leavevmode
list of lines of output text

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{flatten() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.flatten}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{flatten}}{\emph{iterable}}{}
flatten list of lists with N-recursion depth

\end{fulllineitems}

\index{interpolate\_data() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.interpolate_data}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{interpolate\_data}}{\emph{Array1}, \emph{Array2}, \emph{*mesh}}{}
Map Array1 onto Array2 if Array 2 specified
Else, map Array1 onto user defined mesh(float)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{Array1} (\sphinxstyleliteralemphasis{list}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{np.array}) -- (x, y) data

\item {} 
\sphinxstyleliteralstrong{Array2} (\sphinxstyleliteralemphasis{list}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{np.array}) -- (x, y) data

\item {} 
\sphinxstyleliteralstrong{mesh} (\sphinxstyleliteralemphasis{float}) -- stride for interpolation if Array2 absent

\end{itemize}

\item[{Returns}] \leavevmode
{[}(x1, y1), ..., (xn, yn){]}

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{isfinite() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.isfinite}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{isfinite}}{\emph{value}}{}
test if value is infinite

\end{fulllineitems}

\index{not\_header() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.not_header}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{not\_header}}{\emph{line}, \emph{override=False}}{}
Check line in input file for \# or text
Override used for debugging only
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if data, False if header

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.plot}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{plot}}{\emph{*Array}, \emph{**kwargs}}{}
Takes a list of tuples {[}(x1,y1),...,(xn,yn){]} and plots with line format

\textasciitilde{}! bug: axis determined on last loaded plot (could lead to truncation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{Array} (\sphinxstyleliteralemphasis{list}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{np.array}) -- array(s) with shape (N,2)

\item {} 
\sphinxstyleliteralstrong{kwargs} -- accepts xmin, xmax, ymin, ymax as key word args

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib plot object

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_table() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.print_table}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{print\_table}}{\emph{dictionary=None}, \emph{table=None}, \emph{key=None}, \emph{headers=None}}{}
pretty print wrapper of tabulate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{dictionary} (\sphinxstyleliteralemphasis{dict \textbar{} None}) -- dictionary of table content

\item {} 
\sphinxstyleliteralstrong{table} (\sphinxstyleliteralemphasis{list \textbar{} None}) -- list format of table

\item {} 
\sphinxstyleliteralstrong{key} (\sphinxstyleliteralemphasis{sort key \textbar{} None}) -- last operation is list.sort(key=key)

\item {} 
\sphinxstyleliteralstrong{headers} (\sphinxstyleliteralemphasis{list \textbar{} None}) -- list of headers for columns {[}'string', ...'Nstring'{]}

\end{itemize}

\item[{Returns}] \leavevmode
prints table, returns True if no exception raised

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_data() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.read_data}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{read\_data}}{\emph{filename}, \emph{column=1}, \emph{lam=None}, \emph{q=False}, \emph{override=True}}{}
Reads data from space delimited format. Default assumption is that (x, y) are in
the first and second column, respectively. Use column argument to change elsewise.
use argument `q' if data is a function of scattering vector rather than 2theta.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- {[}str{]} path/filename.extension

\item {} 
\sphinxstyleliteralstrong{column} -- {[}int{]} location of f(x), x being the 0th column

\item {} 
\sphinxstyleliteralstrong{lam} -- {[}float{]} wavelength of experimental radiation

\item {} 
\sphinxstyleliteralstrong{q} -- {[}bool{]} whether data is a function of scattering vector q

\item {} 
\sphinxstyleliteralstrong{override} -- {[}bool{]} skip stripping header operation if output is unacceptable

\end{itemize}

\item[{Returns}] \leavevmode
(x,y) array of data like {[}(x1, y1), ..., (xn, yn){]}

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{report\_refined() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.report_refined}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{report\_refined}}{\emph{minimizer\_results\_object\_params}, \emph{tabulate=False}}{}
report values of parameters object with attribute vary=True
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{result} (\sphinxstyleliteralemphasis{lmfit.result}) -- fit result object

\item {} 
\sphinxstyleliteralstrong{tabulate} (\sphinxstyleliteralemphasis{bool \textbar{} False}) -- print or return table

\end{itemize}

\item[{Returns}] \leavevmode
if tabulate is False
print: if tabulate is True

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{rwp() (in module mstack.utilities)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{rst/utilities:mstack.utilities.rwp}}\pysiglinewithargsret{\sphinxcode{mstack.utilities.}\sphinxbfcode{rwp}}{\emph{PDF\_refinement}, \emph{weight=None}}{}
returns the pattern weighted residual for a single data set refinement
e.g.
\begin{quote}

(sum(weight * diff ** 2) / sum(weight * ref.yo ** 2)) ** 0.5
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{PDF\_refinement} -- {[}PdfRefinement instance{]}

\item {} 
\sphinxstyleliteralstrong{weight} -- {[}np.array{]} with same shape as observed data vector Yo

\end{itemize}

\item[{Returns}] \leavevmode
Rwp value

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subsection{utilities.DynamicPlot}
\label{\detokenize{rst/utilities:utilities-dynamicplot}}\index{DynamicPlot (class in mstack.utilities)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.utilities.}\sphinxbfcode{DynamicPlot}}{\emph{fontsize=14}}{}
Bases: \sphinxcode{object}

Plotting utility used to create output for itterative function.
Called in minimizer callback function to create Rwp  vs.  iter
Reserves plot number 100 for this purpose.

call signiture: DynamicPlot(xdata, ydata) --\textgreater{} appended point to plot
\index{\_\_init\_\_() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{fontsize=14}}{}
\end{fulllineitems}

\index{on\_launch() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{on\_launch}}{}{}
set up plot

\end{fulllineitems}

\index{on\_running() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{on\_running}}{\emph{new\_x}, \emph{new\_y}}{}
update plot

\end{fulllineitems}


\end{fulllineitems}



\subsection{utilities.MergeParams}
\label{\detokenize{rst/utilities:utilities-mergeparams}}\index{DynamicPlot (class in mstack.utilities)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.utilities.}\sphinxbfcode{DynamicPlot}}{\emph{fontsize=14}}{}
Bases: \sphinxcode{object}

Plotting utility used to create output for itterative function.
Called in minimizer callback function to create Rwp  vs.  iter
Reserves plot number 100 for this purpose.

call signiture: DynamicPlot(xdata, ydata) --\textgreater{} appended point to plot
\index{\_\_init\_\_() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{fontsize=14}}{}
\end{fulllineitems}

\index{on\_launch() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{on\_launch}}{}{}
set up plot

\end{fulllineitems}

\index{on\_running() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{on\_running}}{\emph{new\_x}, \emph{new\_y}}{}
update plot

\end{fulllineitems}


\end{fulllineitems}



\subsection{utilities.UpdateMethods}
\label{\detokenize{rst/utilities:utilities-updatemethods}}\index{DynamicPlot (class in mstack.utilities)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{mstack.utilities.}\sphinxbfcode{DynamicPlot}}{\emph{fontsize=14}}{}
Bases: \sphinxcode{object}

Plotting utility used to create output for itterative function.
Called in minimizer callback function to create Rwp  vs.  iter
Reserves plot number 100 for this purpose.

call signiture: DynamicPlot(xdata, ydata) --\textgreater{} appended point to plot
\index{\_\_init\_\_() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{fontsize=14}}{}
\end{fulllineitems}

\index{on\_launch() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{on\_launch}}{}{}
set up plot

\end{fulllineitems}

\index{on\_running() (mstack.utilities.DynamicPlot method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{on\_running}}{\emph{new\_x}, \emph{new\_y}}{}
update plot

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{m}
\item {\sphinxstyleindexentry{mstack.background}}\sphinxstyleindexpageref{rst/background:\detokenize{module-mstack.background}}
\item {\sphinxstyleindexentry{mstack.interface}}\sphinxstyleindexpageref{rst/interface:\detokenize{module-mstack.interface}}
\item {\sphinxstyleindexentry{mstack.pairdistributionfunction}}\sphinxstyleindexpageref{rst/pairdistributionfunction:\detokenize{module-mstack.pairdistributionfunction}}
\item {\sphinxstyleindexentry{mstack.refinement}}\sphinxstyleindexpageref{rst/refinement:\detokenize{module-mstack.refinement}}
\item {\sphinxstyleindexentry{mstack.structure}}\sphinxstyleindexpageref{rst/structure:\detokenize{module-mstack.structure}}
\item {\sphinxstyleindexentry{mstack.supercell}}\sphinxstyleindexpageref{rst/supercell:\detokenize{module-mstack.supercell}}
\item {\sphinxstyleindexentry{mstack.utilities}}\sphinxstyleindexpageref{rst/utilities:\detokenize{module-mstack.utilities}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}